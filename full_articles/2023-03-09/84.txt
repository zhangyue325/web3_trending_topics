![](https://img.foresightnews.pro/202303/e1bfebb9872baab01955c4d295cb47c1.png?x-oss-process=style/scale70)

*作者：Oghrul Maharramov*

*致谢：感谢 Justin Drake 和 Bartek Kiepuszewski 的评论.*

*翻译：Junwei*

  


去年，Vitalik Buterin 提出了[多证明者 (Mutli-Provers)](http://mp.weixin.qq.com/s?__biz=MzkyMTQxNTg0MQ==&mid=2247484016&idx=1&sn=a7578e2c3d2652fb18d0d79748781798&chksm=c182bbbef6f532a82f2caffe5d74ddf3db605ae08d3eee3cdd59cb94da1f2bdb888877cb75d6&scene=21#wechat_redirect) 的想法。多证明者的想法归结为使用两个或多个状态转换正确性执行机制（state transition correctness enforcement mechanisms，以下简称 STCEM）来应对可能在 STCEM 中被利用的漏洞。例如，在最终确定相应的状态根之前，验证桥可能需要来自两个不同的 STCEM（例如基于欺诈证明的 STCEM 和基于零知识证明的 STCEM）的声明。此外，Justin Drake 提出了 (https://ethresear.ch/t/2fa-zk-rollups-using-sgx/14462) 2/2 的多证明者的具体实例，它结合了基于零知识证明的 STCEM 和基于 TEE 的 STCEM。

虽然多证明者可能在加强 rollup 的安全属性方面发挥着重要作用，但这并不是验证基于跨链桥协议的开发者和用户关心它的唯一原因。从 Rekt Dashboard(https://rekt.news/leaderboard/) 可以发现，迄今为止绝大多数黑客攻击都是由于利用智能合约漏洞。虽然构建的 STCEM 的复杂性意味着除智能合约之外的可攻击范围相当大，但验证桥实现同样增加了相应的复杂度，意味着潜在的智能合约漏洞攻击仍然是一个主要问题。

在这篇文章中，我概述了冗余验证桥的设计，也称为多验证者 (Multi-Verifier)。

  


**概述**



---

多验证者由四个不同的要素组成：

1.  一个可公开访问的 API，用户 / rollup 可以通过该 API 与跨链桥进行交互，称为  EntryPoint 

2.  验证桥的 Solidity 实现，称为  VerifierSolidity （注意 VerifierSolidity 实现中可能为一套智能合约而不是一个单独的合约）

3.  验证桥的 Vyper 实现，称为   VerifierVyper （注意  VerifierVyper  实现中也可能为一套智能合约而不是一个单独的合约）和

4.  共享存储，命名为  SharedStorage 

多验证者旨在保证 rollup 的安全性，只要其中一个验证器正确实现即可。但该设计无法防范因不正确的协议规范而导致的漏洞。

  


**详细阐述**



---

注意：下面概述的多验证器设计基于 zkRollup 验证桥设计，可以简单地优化实现和 Optimistic Rollup 验证桥一起工作。

**EntryPoint**

 EntryPoint 是一个可公开访问的 API，用户 / rollup 可以通过它与跨链桥进行交互。 EntryPoint 的实现有意保持尽可能简洁，以避免不必要的复杂性，这些复杂性可能导致潜在漏洞的范围更大。 EntryPoint  可以用 Solidity 或 Vyper 具体实现。

 EntryPoint  有两个功能：

1.  调用验证桥的两个具体实例的相应函数，

2.  验证验证桥具体实例的相应函数所返回的值是否相等，并且确实已经写入  SharedStorage 。

下面是用伪代码编写的   EntryPoint  的抽象规范：


```
function appendBatch(batch) {  
    (flagSolidity, storedDataSolidity) = VerifierSolidity.appendBatch(batch)  
    require(flagSolidity == true)  
      
    (flagVyper, storedDataVyper) = VerifierVyper.appendBatch()  
    require(flagVyper == true)  
      
    require(ShareStorage.checkStorage(APPENDBATCH, storedDataSolidity, storedDataVyper) == true)  
}      
  
function finalizeBatch(validityProof, publicInputs) {  
    (flagSolidity, storedDataSolidity) = VerifierSolidity.finalizeBatch(validityProof, publicInputs)  
    require(flagSolidity == true)  
      
    (flagVyper, storedDataVyper) = VerifierVyper.finalizeBatch(validityProof, publicInputs)  
    require(flagVyper == true)  
      
    require(ShareStorage.checkStorage(FINALIZEBATCH, storedDataSolidity, storedDataVyper) == true)  
}  
  
  
function deposit(message) {  
    (flagSolidity, storedDataSolidity) = VerifierSolidity.deposit(message)  
    require(flagSolidity == true)  
      
    (flagVyper, storedDataVyper) = VerifierVyper.deposit(message)  
    require(flagVyper == true)  
      
    require(ShareStorage.checkStorage(DEPOSIT, storedDataSolidity, storedDataVyper) == true)  
}  
  
function withdraw(message) {  
    (flagSolidity, storedDataSolidity) = VerifierSolidity.withdraw(message)  
    require(flagSolidity == true)  
      
    (flagVyper, storedDataVyper) = VerifierVyper.withdraw(message)  
    require(flagVyper == true)  
      
    require(ShareStorage.checkStorage(WITHDRAW, storedDataSolidity, storedDataVyper) == true)  
}  

```
**VerifierSolidity**

 VerifierSolidity  是在 Solidity 中实现的 Rollup 验证桥的具体实例。由于 VerifierSolidity  是  EntryPoint  调用的第一个验证桥实例，因此允许实例改变   SharedStorage  的状态。 VerifierSolidity  预期将返回写入  SharedStorage  的值。

**VerifierVyper**

 VerifierVyper  是在 Vyper 中实现的 Rollup 验证桥的具体实例。由于 VerifierVyper 是  EntryPoint  调用的第二个验证桥实例，因此允许实例读取   SharedStorage  的状态。 VerifierVyper  预期将返回读取自  SharedStorage  的值。

**SharedStorage**

顾名思义，  SharedStorage  是验证桥的两个具体实例的共享存储。只允许 VerifierSolidity  写入，而读取访问是无许可的。 SharedStorage 的实现有意保持尽可能的简洁，以避免不必要的复杂性，这些复杂性可能导致潜在漏洞的范围更大。 SharedStorage  可以在 Solidity 或 Vyper 中具体实现。

下面是用伪代码编写的  SharedStorage  抽象规范：


```
function read(type){  
    if(type == APPENDBATCH) {  
        ...  
    } else if(type == FINALIZEBATCH) {  
        ...  
    } else if(type == DEPOSIT) {  
        ...  
    } else if(type == WITHDRAW) {  
        ...  
    }  
}  
  
function write(type, data){  
    require(msg.sender == addressVerifierSolidity)  
      
    if(type == APPENDBATCH) {  
        ...  
    } else if(type == FINALIZEBATCH) {  
        ...  
    } else if(type == DEPOSIT) {  
        ...  
    } else if(type == WITHDRAW) {  
        ...  
    }  
}  
  
function checkStorage(type, dataSolidity, dataVyper){  
    if(type == APPENDBATCH) {  
        ...  
    } else if(type == FINALIZEBATCH) {  
        ...  
    } else if(type == DEPOSIT) {  
        ...  
    } else if(type == WITHDRAW) {  
        ...  
    }  
}
```
**结论**



---

虽然多验证者增加了跨链桥的成本，增加了协议的冗余，但使开发者和用户能够以更安全的方式与基于验证桥的协议进行交互。为了获得最大的弹性，多验证者应该与多证明者相结合。

**添加Scroller社区管理员微信进入Scroll中文社区**![](https://img.foresightnews.pro/202303/7581ee9e597117f838a203b1b767617f.jpeg?x-oss-process=style/scale70)**👇*点击下方阅读原文，参与 Ethereum Research 的探讨*  
